package com.java;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

public class B extends A {

	public static void main(String[] args) {
		System.out.println("aaa");
	}
	// public B() {
	// }
	//
	// public static void main(String[] args) {
	// new B();
	// System.out.println(B.getList().size());
	//
	// new B();
	// System.out.println(B.getList().size());
	//
	// new B();
	// System.out.println(B.getList().size());
	//
	// new B();
	// System.out.println(B.getList().size());
	//
	// new B();
	// System.out.println(B.getList().size());
	// }

	// public static void main(String[] args) throws IOException {
	// // 字符串超过一定的长度
	// String str = "PJ4XOB2000050电脑板492-1FB";
	// float len0 = str.length();
	// System.out.println("原始的字符串长度为------->" + len0);
	//
	// String ys = compress(str);
	// float len1 = ys.length();
	// System.out.println("压缩后的字符串长度为----->" + len1);
	//
	// String jy = unCompress(ys);
	// System.out.println("\n解压缩后的字符串为--->" + jy);
	// System.out.println("解压缩后的字符串长度为--->" + jy.length());
	//
	// System.out.println("\n压缩比例为" + len1 / len0);
	//
	// // 判断
	// if (str.equals(jy)) {
	// System.out.println("先压缩再解压以后字符串和原来的是一模一样的");
	// }
	// }
	//
	// /**
	// * 字符串的压缩
	// *
	// * @param str
	// * 待压缩的字符串
	// * @return 返回压缩后的字符串
	// * @throws IOException
	// */
	// public static String compress(String str) throws IOException {
	// if (null == str || str.length() <= 0) {
	// return str;
	// }
	// // 创建一个新的 byte 数组输出流
	// ByteArrayOutputStream out = new ByteArrayOutputStream();
	// // 使用默认缓冲区大小创建新的输出流
	// GZIPOutputStream gzip = new GZIPOutputStream(out);
	// // 将 b.length 个字节写入此输出流
	// gzip.write(str.getBytes());
	// gzip.close();
	// // 使用指定的 charsetName，通过解码字节将缓冲区内容转换为字符串
	// return out.toString("ISO-8859-1");
	// }
	//
	// /**
	// * 字符串的解压
	// *
	// * @param str
	// * 对字符串解压
	// * @return 返回解压缩后的字符串
	// * @throws IOException
	// */
	// public static String unCompress(String str) throws IOException {
	// if (null == str || str.length() <= 0) {
	// return str;
	// }
	// // 创建一个新的 byte 数组输出流
	// ByteArrayOutputStream out = new ByteArrayOutputStream();
	// // 创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组
	// ByteArrayInputStream in = new
	// ByteArrayInputStream(str.getBytes("ISO-8859-1"));
	// // 使用默认缓冲区大小创建新的输入流
	// GZIPInputStream gzip = new GZIPInputStream(in);
	// byte[] buffer = new byte[256];
	// int n = 0;
	// while ((n = gzip.read(buffer)) >= 0) {// 将未压缩数据读入字节数组
	// // 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此 byte数组输出流
	// out.write(buffer, 0, n);
	// }
	// // 使用指定的 charsetName，通过解码字节将缓冲区内容转换为字符串
	// return out.toString("GBK");
	// }

	private static String encode = "utf-8";// "ISO-8859-1"

	public String getEncode() {
		return encode;
	}

	/* * 字符串压缩为字节数组 */
	public static byte[] compressToByte(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		GZIPOutputStream gzip;
		try {
			gzip = new GZIPOutputStream(out);
			gzip.write(str.getBytes(encode));
			gzip.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return out.toByteArray();
	}

	/* * 字符串压缩为字节数组 */
	public static byte[] compressToByte(String str, String encoding) {
		if (str == null || str.length() == 0) {
			return null;
		}
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		GZIPOutputStream gzip;
		try {
			gzip = new GZIPOutputStream(out);
			gzip.write(str.getBytes(encoding));
			gzip.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return out.toByteArray();
	}

	/* * 字节数组解压缩后返回字符串 */
	public static String uncompressToString(byte[] b) {
		if (b == null || b.length == 0) {
			return null;
		}
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ByteArrayInputStream in = new ByteArrayInputStream(b);
		try {
			GZIPInputStream gunzip = new GZIPInputStream(in);
			byte[] buffer = new byte[256];
			int n;
			while ((n = gunzip.read(buffer)) >= 0) {
				out.write(buffer, 0, n);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		return out.toString();
	}

	/* * 字节数组解压缩后返回字符串 */
	public static String uncompressToString(byte[] b, String encoding) {
		if (b == null || b.length == 0) {
			return null;
		}
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ByteArrayInputStream in = new ByteArrayInputStream(b);
		try {
			GZIPInputStream gunzip = new GZIPInputStream(in);
			byte[] buffer = new byte[256];
			int n;
			while ((n = gunzip.read(buffer)) >= 0) {
				out.write(buffer, 0, n);
			}
			return out.toString(encoding);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public void testdd() {
		
	}
	
	@Override
	public boolean isA() {
		// TODO Auto-generated method stub
		super.isA();
		return true;
	}
}
